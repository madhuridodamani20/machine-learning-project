# -*- coding: utf-8 -*-
"""NETFLIX

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iyp95UKWigAmbDqjmR3VYSdKBMUR8N_D
"""

#importing lib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('mymoviedb.csv',lineterminator='\n')
df.head()

#viewing dataset info
df.info()

#exploring genre column
df['Genre'].head()

#check for duplicated rows
df.duplicated().sum()

#exploring summary statistics
df.describe()

#casting column a
df["Release_Date"] = pd.to_datetime(df["Release_Date"])
print(df)

df['Release_Date']=pd.to_datetime(df['Release_Date'])
df['Only_Date']=df['Release_Date'].dt.date
df['Year']=df['Release_Date'].dt.year
df['Year'].dtypes

#Dropping Overview,Original_Language and Poster-Url
#making List of column to be dropped
cols=['Overview','Original_Language','Poster_Url']
df.drop(cols,axis=1,inplace=True)
df.columns

df.head()

def catigorize_col(df,col,labels):
  #setting the edges to cut the column accordingly
  edges=[
      df[col].describe()['min'],
      df[col].describe()['25%'],
      df[col].describe()['50%'],
      df[col].describe()['75%'],
      df[col].describe()['max']
  ]
  #cut the column into categories
  df[col]=pd.cut(df[col],bins=edges,labels=labels,duplicates='drop')
  return df

labels=['not_popular','below_avg','average','popular']
df=catigorize_col(df,'Vote_Average',labels)
print(df['Vote_Average'].unique())

#exploring column
df['Vote_Average'].value_counts()

#dropping NaNs
df.dropna(inplace=True)
#confirming
df.isna().sum()

df.head()

#split the strings into lists
df['Genre'  ]=df['Genre'].apply(lambda x:x.split(','))
#explode the lists
df=df.explode('Genre').reset_index(drop=True)
df.head()

#casting column into category
df['Genre']=df['Genre'].astype('category')
#confirming changes
df['Genre'].dtypes

df.info()

df.nunique()

#------Data Visualization------
#setting up seaborn configurations
sns.set_style('whitegrid')

#Q1:what is the most frequent genre in the dataset?
#showing stats.on genre column
df['Genre'].describe()

#Visualizing the Genre column distribution
sns.catplot(y='Genre',data=df,kind='count',
    order=df['Genre'].value_counts().index,
    color='#4287f5')
plt.title('Genre Column Distribution')
plt.show()

#Q2:what genres has highest votes?
#visualizing the vote_Aveeage column distribution
sns.catplot(
    y='Vote_Average',
    data=df,
    kind='count',
    order=df['Vote_Average'].value_counts().index,
    color='#4287f5'
)

plt.title('Vote_Average Distribution')
plt.show()

#Q3:what movie got the highest genre?
#checking max popularly in dataset
df[df['Popularity']==df['Popularity'].max()]

#Q4:what movie got the lowest popularity? whats its genre?
#checking max popularly in dataset
df[df['Popularity']==df['Popularity'].min()]

#Q5:which year has the most filmmed movies?
df['Release_Date'].hist()
plt.title('Release_Date column Distribution')
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, classification_report

le = LabelEncoder()
df['Vote_Average_Enc'] = le.fit_transform(df['Vote_Average'])

X = df[['Popularity', 'Vote_Count']]
y = df['Vote_Average_Enc']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

plt.figure(figsize=(6,4))
sns.heatmap(df[['Popularity', 'Vote_Count', 'Year']].corr(),annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap")
plt.show()

plt.figure(figsize=(6,4))
sns.scatterplot(
    x='Popularity',
    y='Vote_Count',
    hue='Vote_Average',
    data=df,
    alpha=0.6
)
plt.title("Popularity vs Vote Count")
plt.show()


cm = confusion_matrix(y_test, y_pred)

plt.figure(figsize=(6,4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()
print(classification_report(y_test, y_pred))